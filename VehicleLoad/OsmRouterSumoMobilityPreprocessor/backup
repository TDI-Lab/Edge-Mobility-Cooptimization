package emufog;
import eu.bitm.NominatimReverseGeocoding.NominatimReverseGeocodingJAPI;
import eu.bitm.NominatimReverseGeocoding.Address;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

//import com.sun.tools.javac.util.List;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.LineNumberReader;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask; 

import org.eclipse.jdt.internal.jarinjarloader.*;

public class Processor {

	
	Processor(){
		
	}
	
	/**
	 * @param skiplines
	 */
	
	
	
	public String removeColon(String str) {
	    if (str != null && str.length() > 0 && str.charAt(str.length() - 1) == ':') {
	        str = str.substring(0, str.length() - 1);
	    }
	    return str;
	}
	
	public void removLinks(int skiplines, String sPath1, String sPath2, String dPath) {
		
		
		int i = 1, j;
		Address a;
		int zoom = 18;
		double lat, lon;
		String SrMap = sPath1;
		String SrcLinks = sPath2;
		String Ds = dPath;
	    String line1;
	    int lineNumber;
	    String[] strArgs;
	    String stateCountyCity="";
	    FileWriter fileWriter = null;
	    String NEW_LINE_SEPARATOR = "\n";
	    ConcurrentHashMap<String, Integer> hash_map = new ConcurrentHashMap<String,Integer>(); 
	    //FutureTask<String> task1;
	    //FutureTask<String> task2;
	    ExecutorService executorService = Executors.newFixedThreadPool(1);
	    //FutureTask randomNumberTasks = new FutureTask; 
	    //ExecutorService exec = Executors.newFixedThreadPool(3);
	       
	    //[] tasks = new ArrayList<Callable>();
	    //List<Callable> tasks = new ArrayList<Callable>();
		try {
			LineNumberReader br = new LineNumberReader(new FileReader(SrMap));
	           
	            while (i < skiplines) {//6
	            	line1=br.readLine();
	                i++;
	            }
	            while((line1 = br.readLine())!= null) {
	            	
	            	strArgs = line1.split("\\s+");
	            	j = strArgs.length;
	                if (j>3) {
	                	
	                	hash_map.put(removeColon(strArgs[1]),1);//node id without colon
	                    
	                	}
	                	else {
	                		//System.out.println("endOfFole");
	                	}
	                } 
	            
	            br.close();   
		}
		catch (Exception e) {
	        System.out.println("Error in FileReader !!!");
	        e.printStackTrace();
	    } 
		
		
		
		try {
			fileWriter = new FileWriter(Ds);
			
			LineNumberReader br = new LineNumberReader(new FileReader(SrcLinks));
	           
	            while (i < skiplines) {
	            	line1=br.readLine();
	            	fileWriter.append(line1);
	                fileWriter.append(NEW_LINE_SEPARATOR);
	                i++;
	            }
	            //link L1:  N22130677:1.0.0.1 N104721 N104722 N104723 N104724 

	            //int lineNum = 0;
	            while((line1 = br.readLine()) != null) {
	            	boolean counter1 = false;
	            	boolean counter2 = false;
	            	strArgs = line1.split("\\s+");
		            	j = strArgs.length;
		                if (j>1) {
		                	
		                	//Callable callable1 = new SearchTask(line1, hash_map); 
		                	//Future<String> future = executorService.submit(callable1);
		                	//String line2 = future.get();
							//String[] strArgs2 = line2.split("\\s+");
							
							
		                	
		                	String [] strArgs;//take care
		        	    	int j, k ;
		        	    	k = 2;
		        			strArgs = searchWords.split("\\s+");
		        	        j = strArgs.length;
		        	        String candidateNode;
		        	        
		        			if (j > 2){
		        				 while (k<=j)
		        			        {
		        					 int iend = strArgs[k].indexOf(":"); //this finds the first occurrence of ":" 
		        					 if (iend != -1) 
		        						 candidateNode= strArgs[k].substring(0 , iend); 
		        					 
		        					 candidateNode= strArgs[k]; 
		        					 if (mapWords.containsKey(candidateNode)){
		        						 
		        					 }
		        					 else {
		        						 searchWords.replace(strArgs[k], "");
		        					 }
		        					 k++;
		        			        }
		        				}
		        		    
		                	
		                	
		                	
		                	
		                	if( strArgs2.length > 3) {
								fileWriter.append(line2);
								fileWriter.append(NEW_LINE_SEPARATOR);
							}
							else {
							
							}
										
						} 
	            
	            br.close();   
	            executorService.shutdown();
	            }
		}
    	catch (Exception e) 
		{
                    System.out.println("Error in FileWriter !!!");
                    e.printStackTrace();
        } 
		finally {
                     
                try {
                    fileWriter.flush();
                    fileWriter.close();
                } catch (IOException e) {
                    System.out.println("Error while flushing/closing fileWriter !!!");
                    e.printStackTrace();
                }
        }
	}
		
	
	public void removNodes(int skiplines1, int skiplines2, String sPath1, String sPath2, String dPath) {
	
		
	int i = 1, j;
	Address a;
	int zoom = 18;
	double lat, lon;
	String SrMap = sPath1;
	String SrcNodes = sPath2;
	String Ds = dPath;
    String line1, line2;
    int lineNumber = 0;
    String[] strArgs;
    FileWriter fileWriter = null;
    String NEW_LINE_SEPARATOR = "\n";
    ConcurrentHashMap<String, Integer> hash_map = new ConcurrentHashMap<String,Integer>(); 
    
	try {
		LineNumberReader br = new LineNumberReader(new FileReader(SrMap));
           
            while (i < skiplines1) {//6
            	line1=br.readLine();
            	i++;
            }
            while((line1 = br.readLine())!= null) {
            	
            	strArgs = line1.split("\\s+");
            	j = strArgs.length;
                if (j>3) {
                	
                	hash_map.put(removeColon(strArgs[1]),1);//node id without colon
                
                	}
                	else {
                		//System.out.println("endOfFole");
                	}
                } 
            
            br.close();   
	}
	catch (Exception e) {
        System.out.println("Error in FileReader !!!");
        e.printStackTrace();
    } 
	
	
	
	try {
		fileWriter = new FileWriter(Ds);
		
		LineNumberReader br = new LineNumberReader(new FileReader(SrcNodes));
           
            while (i < skiplines2) {//0
            	line1=br.readLine();
            	fileWriter.append(line1);
                fileWriter.append(NEW_LINE_SEPARATOR);
                i++;
            }
            
            //int lineNum = 0;
            while((line1 = br.readLine()) != null) {
            	/*
            	lineNumber = br.getLineNumber();
            	if (lineNumber == 20000)
        			break;
            	*/
            	strArgs = line1.split("\\s+");
	            	j = strArgs.length;
	                if (j>1) {
	                	if (hash_map.containsKey(strArgs[1])){
	                		fileWriter.append(line1);
		                	fileWriter.append(NEW_LINE_SEPARATOR);
	                	}
	                }
                	else {
                		//System.out.println("endOfFole");
                	}
	             					
            } 
            
            br.close();   
		}
    	catch (Exception e) 
		{
                    System.out.println("Error in FileWriter !!!");
                    e.printStackTrace();
        } 
		finally {
                     
                try {
                    fileWriter.flush();
                    fileWriter.close();
                } catch (IOException e) {
                    System.out.println("Error while flushing/closing fileWriter !!!");
                    e.printStackTrace();
                }
        }
}
	
	public static class SearchTask implements Callable<String> {
	     private String localCounter = "*";
	     private ConcurrentHashMap<String, Integer> mapWords;
	     private String searchWords;

	     public SearchTask(String searchWords, ConcurrentHashMap<String, Integer> mapWords) {
	         this.searchWords = searchWords;
	         this.mapWords = mapWords;
	         
	     }
	     @Override
	     public String call() throws Exception {
	    	String [] strArgs;//take care
	    	int j, k ;
	    	k = 2;
			strArgs = searchWords.split("\\s+");
	        j = strArgs.length;
	        String candidateNode;
	        
			if (j > 2){
				 while (k<=j)
			        {
					 int iend = strArgs[k].indexOf(":"); //this finds the first occurrence of ":" 
					 if (iend != -1) 
						 candidateNode= strArgs[k].substring(0 , iend); 
					 
					 candidateNode= strArgs[k]; 
					 if (mapWords.containsKey(candidateNode)){
						 
					 }
					 else {
						 searchWords.replace(strArgs[k], "");
					 }
					 k++;
			        }
				}
		    
		     return searchWords;
	     }        
	}
	
	
//	public class Singleton {
//	    private static final Singleton inst= new Singleton();
//
//	    private Singleton() {
//	        super();
//	    }
//
//	    public synchronized void writeToFile(String str) {
//	        // Do whatever
//	    }
//
//	    public static Singleton getInstance() {
//	        return inst;
//	    }
//
//	}
	public void findLinesContainCities(int skiplines, String state, String city, String sPath, String dPath) {
		
		int i = 1, j;
		Address a;
		int zoom = 18;
		double lat, lon;
		String line;
        String[] strArgs;
        int lineNumber;
        String stateCountyCity="";
        FileWriter fileWriter = null;
        String NEW_LINE_SEPARATOR = "\n";
        String COMMA_DELIMITER = ",";
		
        try {
			fileWriter = new FileWriter(dPath);
			
			LineNumberReader br = new LineNumberReader(new FileReader(sPath));
	           
	            while (i < skiplines) {
	            	line=br.readLine();
	                fileWriter.append(line);
	                fileWriter.append(NEW_LINE_SEPARATOR);
	                
	             i++;
	            }
	            while((line = br.readLine())!= null) {
	            	
	            	lineNumber = br.getLineNumber();
	            	
	            	
	            	strArgs = line.split("\\s+");
	            	j = strArgs.length;
	                if (j>3) {
	                	if ((strArgs[4].compareTo(state) == 0)&&(strArgs[5].compareTo(city) == 0)) {
	                
	                		fileWriter.append(line);
	                		fileWriter.append(NEW_LINE_SEPARATOR);
	                	}
	                	else {
	                		//System.out.println("endOfFole");
	                	}
	                } 
	            	//if (lineNumber==100000)
	               // break;
	            }
	            br.close();   
		}
		catch (Exception e) {
            System.out.println("Error in FileWriter !!!");
            e.printStackTrace();
        } finally {
             
            try {
                fileWriter.flush();
                fileWriter.close();
            } catch (IOException e) {
                System.out.println("Error while flushing/closing fileWriter !!!");
                e.printStackTrace();
            }
             
        }
		
	         
				  
	}

	public void splitCountry(int skiplines, String continent, String country, String sPath, String dPath) {
	//node.geo   <node_id>:   <continent>   <country>   <region>   <city>   <latitude>   <longitude> 
		
		int i = 1, j;
		Address a;
		int zoom = 18;
		double lat, lon;
		String Sr = sPath;
		String Ds = dPath;//input file for 4.5 hours and 89354 tasks
        String line;
        int lineNumber;
        String[] strArgs;
        String stateCountyCity="";
        FileWriter fileWriter = null;
        String NEW_LINE_SEPARATOR = "\n";
        
		try {
			fileWriter = new FileWriter(Ds);
			
			LineNumberReader br = new LineNumberReader(new FileReader(Sr));
	           
	            while (i < skiplines) {
	            	line=br.readLine();
	                fileWriter.append(line);
	                fileWriter.append(NEW_LINE_SEPARATOR);
	                
	             i++;
	            }
	            while((line = br.readLine())!= null) {
	            	
	            	lineNumber = br.getLineNumber();
	            	
	            	//System.out.println("line");
//	            	if (lineNumber==10000) {
//	            	        System.out.println("line: "+lineNumber);
//	            	        
//	            	}
	            	strArgs = line.split("\\s+");
	            	j = strArgs.length;
	                if (j>3) {
	                	if ((strArgs[3].compareTo(country) == 0)&&(strArgs[2].compareTo(continent) == 0)) {
	                
	                		fileWriter.append(line);
	                		fileWriter.append(NEW_LINE_SEPARATOR);
	                	}
	                	else {
	                		//System.out.println("endOfFole");
	                	}
	                } 
	            }
	            br.close();   
		}
		catch (Exception e) {
            System.out.println("Error in FileWriter !!!");
            e.printStackTrace();
        } finally {
             
            try {
                fileWriter.flush();
                fileWriter.close();
            } catch (IOException e) {
                System.out.println("Error while flushing/closing fileWriter !!!");
                e.printStackTrace();
            }
             
        }
		
		
	}
	
	public void findCitiesForCountry(int skiplines, String country, String city) {
		//find city form file or API and write it to CSV file
		int i = 1, j;
		Address a;
		int zoom = 18;
		double lat, lon;
		String Sr = "C:/Users/rooyesh/eclipse-workspace/CaidaProcessor/Caida/topo.nodes.geo";
		String Ds = "C:/Users/rooyesh/eclipse-workspace/CaidaProcessor/Caida/topo.nodes.geo.csv";//input file for 4.5 hours and 89354 tasks
        String line;
        String[] strArgs;
        String stateCountyCity="";
        FileWriter fileWriter = null;
        String NEW_LINE_SEPARATOR = "\n";
        String COMMA_DELIMITER = ",";
		try {
			fileWriter = new FileWriter(Ds);
			String FILE_HEADER2 = "Node,City,Country";
			fileWriter.append(FILE_HEADER2.toString());
			fileWriter.append(NEW_LINE_SEPARATOR);
			
			LineNumberReader br = new LineNumberReader(new FileReader(Sr));
	           
	            while (i <skiplines) {
	                br.readLine();
	             i++;
	            }
	            while((line = br.readLine())!= null) {
	            	
	            	    int lineNumber = br.getLineNumber();
	            	    if (lineNumber >= 19 && lineNumber <= 29) {
	                
	                strArgs = line.split("\\s+");
	                j = strArgs.length;
	                if (j>3) {
		                lat = Double.parseDouble(strArgs[j-2]);
		                lon = Double.parseDouble(strArgs[j-1]);
		                
		                //fileWriter.append(Double.toString(lat));
		                fileWriter.append(strArgs[1]);
		                fileWriter.append(COMMA_DELIMITER); 
		                
		                System.out.println("line: "+lineNumber);
					
				    if (strArgs[5].compareTo("***") ==0) {
				    	//https://www.daniel-braun.com/ java -jar reverseGeocoding.jar -lat 57.1653392 -lon -2.1056118
				    	NominatimReverseGeocodingJAPI nominatim1 = new NominatimReverseGeocodingJAPI(zoom); //create instance with default zoom level (18)
						a = nominatim1.getAdress(lat, lon); //returns Address object for the given position
					    System.out.println(a);
					    stateCountyCity= a.getState()+" "+a.getCounty()+" "+a.getCity();
					    fileWriter.append(stateCountyCity);
					    
				    }
				    else {
				    	stateCountyCity="";
				    	for (int k=5;k<=(j-3);k++)
				    		stateCountyCity=stateCountyCity+" "+strArgs[k];
				    		fileWriter.append(stateCountyCity);
				    }
				    fileWriter.append(COMMA_DELIMITER); 
				    fileWriter.append(strArgs[3]);////fileWriter.append(a.getCountry()); 
				    //https://stackoverflow.com/questions/14155049/iso2-country-code-from-country-name
				    //String code =  CountryCode.findByName("Switzerland").get(0).name();
				    fileWriter.append(COMMA_DELIMITER); 
				    
				    fileWriter.append(NEW_LINE_SEPARATOR);
		            
		
	            }
	            else {
	                	System.out.println("invalid line");
	            }
		            //System.out.println("CSV file was created successfully !!!");
		     //break;     
	         } 
	            }
	            br.close();   
		}
		catch (Exception e) {
            System.out.println("Error in CsvFileWriter !!!");
            e.printStackTrace();
        } finally {
             
            try {
                fileWriter.flush();
                fileWriter.close();
            } catch (IOException e) {
                System.out.println("Error while flushing/closing fileWriter !!!");
                e.printStackTrace();
            }
             
        }
		
	}

	public void printFiletoConsol (String sPath, int numLines) {
		int i = 0;
		String line;
		 try {
				
				LineNumberReader br = new LineNumberReader(new FileReader(sPath));
		           
	            while (i < numLines) {
	            	line=br.readLine();
	            	System.out.println(line);
	            	i++;
	           }
           br.close();   
		}
		catch (Exception e) {
            System.out.println("Error in FileReader !!!");
            e.printStackTrace();
        }
	
		
	}
		
	public void printtoFile (String sPath,String dPath, int numLines) {
		int i = 0;
		String line1;
		FileWriter fileWriter = null;
	    String NEW_LINE_SEPARATOR = "\n";
		 try {
				fileWriter = new FileWriter(dPath);
				
				LineNumberReader br = new LineNumberReader(new FileReader(sPath));
		           
		            while (i < numLines) {
		            	line1=br.readLine();
		            	fileWriter.append(line1);
		                fileWriter.append(NEW_LINE_SEPARATOR);
		                i++;
		            }
           br.close();   
		}
		 catch (Exception e) 
			{
	                    System.out.println("Error in FileWriter !!!");
	                    e.printStackTrace();
	        } 
			finally {
	                     
	                try {
	                    fileWriter.flush();
	                    fileWriter.close();
	                } catch (IOException e) {
	                    System.out.println("Error while flushing/closing fileWriter !!!");
	                    e.printStackTrace();
	                }
	        }
		
	}

	
	public static int countLines(String filename) throws IOException {
	    InputStream is = new BufferedInputStream(new FileInputStream(filename));
	    try {
	        byte[] c = new byte[1024];

	        int readChars = is.read(c);
	        if (readChars == -1) {
	            // bail out if nothing to read
	            return 0;
	        }

	        // make it easy for the optimizer to tune this loop
	        int count = 0;
	        while (readChars == 1024) {
	            for (int i=0; i<1024;) {
	                if (c[i++] == '\n') {
	                    ++count;
	                }
	            }
	            readChars = is.read(c);
	        }

	        // count remaining characters
	        while (readChars != -1) {
	            //System.out.println(readChars);
	            for (int i=0; i<readChars; ++i) {
	                if (c[i] == '\n') {
	                    ++count;
	                }
	            }
	            readChars = is.read(c);
	        }

	        return count == 0 ? 1 : count;
	    } finally {
	        is.close();
	    }
	}
	
}


public void osm(){
	 /*
	 MapPolygon bermudas = new MapPolygonImpl(c(49, 1), c(45, 10), c(40, 5));
	 map().addMapPolygon(bermudas);
	 map().addMapPolygon(new MapPolygonImpl(usAnnLayerCore, "RouterBoundry", ebersheim, darmstadt, eberstadt, empty));
		*/
 
 	
 
 LayerGroup germanyGroup = new LayerGroup("Germany");
 Layer germanyWestLayer = germanyGroup.addLayer("Germany West");
 Layer germanyEastLayer = germanyGroup.addLayer("Germany East");
 MapMarkerDot eberstadt = new MapMarkerDot(germanyEastLayer, "Eberstadt", 49.814284999, 8.642065999);
 MapMarkerDot ebersheim = new MapMarkerDot(germanyWestLayer, "Ebersheim", 49.91, 8.24);
 MapMarkerDot empty = new MapMarkerDot(germanyEastLayer, 49.71, 8.64);
 MapMarkerDot darmstadt = new MapMarkerDot(germanyEastLayer, "Darmstadt", 49.8588, 8.643);
 map().addMapMarker(eberstadt);
 map().addMapMarker(ebersheim);
 map().addMapMarker(empty);
 Layer franceLayer = treeMap.addLayer("France");
 map().addMapMarker(new MapMarkerDot(franceLayer, "La Gallerie", 48.71, -1));
 map().addMapMarker(new MapMarkerDot(43.604, 1.444));
 map().addMapMarker(new MapMarkerCircle(53.343, -6.267, 0.666));
 map().addMapRectangle(new MapRectangleImpl(new Coordinate(53.343, -6.267), new Coordinate(43.604, 1.444)));
 map().addMapMarker(darmstadt);
 treeMap.addLayer(germanyWestLayer);
 treeMap.addLayer(germanyEastLayer);
 //Coordinate paris = new Coordinate(48.8567, 2.3508);
 //map.addMapMarker(new MapMarkerDot("Paris", paris));
 map().addMapMarker(new MapMarkerCircle(germanyWestLayer, "North of Suisse", new Coordinate(48, 7), .5));
 Layer spain = treeMap.addLayer("Spain");
 map().addMapMarker(new MapMarkerCircle(spain, "La Garena", new Coordinate(40.4838, -3.39), .002));
 spain.setVisible(Boolean.TRUE);
 //Layer wales = treeMap.addLayer("UK");
	// map().addMapRectangle(new MapRectangleImpl(wales, "Wales", co(53.35, -4.57), co(51.64, -2.63)));
	
 
 //double meters = coreRouterDistance;
 // coef = coreRouterDistance * 0.0000089;
/* 
	int j = 0;
	double max = dis_long>dis_lat? dis_long:dis_lat;
	
 while (j<core) {
	 double randomValue = (max) * r.nextDouble();
	 //System.out.println("dou"+randomValue+" "+dis_long+" "+dis_lat);
		
	 //meters = randomValue;
	 coef = randomValue * 0.0000089;
	 
	 new_lat = base_lat + 10*coef;
 	 new_long = base_long + 10*coef / Math.cos(new_lat * 0.018);
	 
	 new_coor = new Coordinate(new_lat, new_long);
 	 Point p1 = map().getMapPosition(new_coor.getLat(),new_coor.getLon());
		
 	 if (tp.contains(p1)) {
 		  
		 MapMarkerDot m = new MapMarkerDot(usAnnLayerCore, new_coor);
		 m.setColor(Color.RED);
		 m.setBackColor(Color.RED);
		    
		 map().addMapMarker(m);
		 j++;
		 System.out.println("heyyyy");
		}
	 System.out.println("heyyyy111111");

 }
*/
}






private static void readMoblityData() {

			File folder = new File(Constants.BASE_ADDRESS+"inputi");
			File[] listOfFiles = folder.listFiles();
			//System.out.println("h);
			
			//Arrays.sort(listOfFiles);
			//int[] ordem = readDevicePathOrder(listOfFiles[listOfFiles.length - 1]);
			
			for (int i = 0; i < getSmartThings().size(); i++) {
				//System.out.println("hehe "+ordem[i]);
				//System.out.println("hehe "+listOfFiles[ordem[i]].getName());
				readDevicePath(getSmartThings().get(i), "inputi/veh"+i+".csv");
				//getSmartThings.
			//break;
			}
		}

		private static int[] readDevicePathOrder(File filename) {

			String line = "";
			String cvsSplitBy = "\t";
			//System.out.println(filename);
			
			try (BufferedReader br = new BufferedReader(new FileReader(filename))) {

				int i = 1;
				while (((line = br.readLine()) != null)) {
					if (i == 1) {
						break;
					}
					i++;
				}
				// use comma as separator
				String[] position = line.split(cvsSplitBy);
				int order[] = new int[getSmartThings().size()];
				for (int j = 0; j < getSmartThings().size(); j++) {
					order[j] = Integer.valueOf(position[j]);
					
					
				}
				Arrays.sort(order);
				return order;

			} catch (IOException e) {
				e.printStackTrace();
			}
			return null;
		}

		private static void readDevicePath(MobileDevice st, String filename) {

			String line = "";
			String cvsSplitBy = ",";
			System.out.println("st "+st.getName()+" file "+filename);
			try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
				int i = 0;
				while ((line = br.readLine()) != null) {

					// use comma as separator
					String[] position = line.split(cvsSplitBy);

					st.getPath().add(position);//read the  whole file and save to paths
					//System.out.println("line "+ line);
					i++;
				}

				Coordinate coordinate = new Coordinate();//format??next/new coordinate
				coordinate.setInitialCoordinate(st);//set the first path as initial
				//System.out.println("coo "+coordinate.getCoordX());
				
				saveMobility(st);
				
			} catch (IOException e) {
				e.printStackTrace();
			}

		}


