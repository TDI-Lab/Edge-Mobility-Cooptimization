package EdgeEPOS.PlacementMethods;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import fog.entities.FogDevice;
import EdgeEPOS.CostComponents.ComProcessDepStorCost;
import EdgeEPOS.CostComponents.ComboCosts;
import EdgeEPOS.CostComponents.EnergyCost;
import EdgeEPOS.CostComponents.MetricsForVehisFromIntermediateAP;
import EdgeEPOS.CostComponents.RunCost;
import EdgeEPOS.CostComponents.ServiceDelay;
import EdgeEPOS.CostComponents.Violation;
import EdgeEPOS.Setting.Constants;
import EdgeEPOS.Setting.MobileARservice;

import EdgeEPOS.Utility.Utility;
import experiment.IEPOSExperiment;

/**
 *
 * @author rooyesh
 *
 * This is the main class of the simulation, that runs different placement policies (e.g. optimization, greedy algorithms, all
 * cloud)
 */
public class Method {

    protected short[][] x_backup; 
    private boolean[] deploy_backup;
    
    //Cost lcost;
	ComProcessDepStorCost costOfComProcDep;
	ServiceDelay sD;
	EnergyCost eC;
	Violation v;
	
	public int run;
    private int type;//type of placement method 
    
    protected ServiceDeploymentMethod scheme;
  
      
    /**
     * Constructor of this class.
     *
     * @param scheme
     * @param numFogNodes
     * @param numServices
     * @param numCloudServers
     */
    public Method(ServiceDeploymentMethod scheme) {

    	//this.hopLevel = Constants.hopLevel;
    	//this.lambda = Constants.lambda;
        
        this.scheme = scheme;
        this.type = scheme.methodType;
        this.run = scheme.run;
        
        x_backup = new short [scheme.numst][Constants.NUM_EDGE_ROUTERS+Constants.NUM_BACKBONE_ROUTERS];
        deploy_backup = new boolean [Constants.NUM_EDGE_ROUTERS+Constants.NUM_BACKBONE_ROUTERS];
        
    }

    /**
	* Backs up previous placement (Gplan.x , Gplan.deployplan) at each run for later calculation of costs such as deployment cost
	*
	*/
	private void backupAllPlacements() {
	  
		for (int j = 0; j < Constants.NUM_EDGE_ROUTERS+Constants.NUM_BACKBONE_ROUTERS; j++) {
		    deploy_backup[j] = scheme.GPlan.deployPlan[j];
		   
		    for (int a = 0; a < scheme.numst; a++) {
		    	x_backup[a][j] = scheme.GPlan.x[a][j];
		    	scheme.GPlan.x[a][j] = 0;
		    	
		    }
	  }
		for (int j = 0; j < 2*(Constants.NUM_EDGE_ROUTERS+Constants.NUM_BACKBONE_ROUTERS); j++) {
			 	 scheme.GPlan.utilPlan[j] = 0;
			     scheme.GPlan.wlPlan[j] = 0;
		}
		for (int j = 0; j < (Constants.NUM_EDGE_ROUTERS+Constants.NUM_BACKBONE_ROUTERS); j++) 
			scheme.GPlan.energyPlan[j] = 0;
	}
  
    
    /**
     * 
     * @param args 
     * @param timestamp 
     * @param  
     * @param 
     * @param
     * @param 
     * @return returns generated plans
     *  Runs the placement method
     */
    public void run(String[] args1, int run, int timestamp, List<FogDevice> serverCloudlets) {
        
    	backupAllPlacements();
        this.run = run;
        this.scheme.run = run;
        System.out.println("----------------------------------------------");
        System.out.println("Run "+this.scheme.run+", Method type: "+this.type);
        
        if (type == ServiceDeploymentMethod.OPTIMAL_SERVICE_DEFAULT_ROUTE) {
            runOptimalSrv(args1, timestamp, serverCloudlets);
        }
        else if (type == ServiceDeploymentMethod.OPTIMAL_SERVICE_OPTIMIZED_ROUTE) {
        	runOptimalSrv(args1, timestamp, serverCloudlets);
        } 
        else if (type == ServiceDeploymentMethod.BASE_SERVICE_DEFAULT_ROUTE) { 
        	 runBaseSrv(timestamp, serverCloudlets);
        } 
        else if (type == ServiceDeploymentMethod.BASE_SERVICE_OPTIMIZED_ROUTE) { 
        	 runBaseSrv(timestamp, serverCloudlets);
        }
        else if (type == ServiceDeploymentMethod.FF_SERVICE_OPTIMIZED_ROUTE) {
        	runFFSrv(timestamp, serverCloudlets);
        }
        else if (type == ServiceDeploymentMethod.FF_SERVICE_DEFAULT_ROUTE) {
        	runFFSrv(timestamp, serverCloudlets);
        }
    			
       
    }

    private void runFFSrv(int timestamp, List<FogDevice> serverCloudlets) {
		
    	scheme.optBeta  = 0;
		scheme.optNumPlan = 1;
    	
		Plan [] plans = new Plan [Constants.NUM_EDGE_ROUTERS]; //array of candidate plans generated by all agents
		short pin = 0;
		Plan p;
		
		
    	System.out.println("------------------------------Plan generation------------------------------");
        for (int i = 0; i < scheme.agents.size(); i++) {
        	
        	p = new Plan(true, i, pin, scheme.agents.get(i).serviceList.size(), deploy_backup);//deployment from previous run and workload=0. do not change here, keep for G-lC
        	
        	if(i != 0) {//The agents other than the first one should receive an updated state of the network with respect to the planning of other agents
        		//p.updateNetUtilStatus(plans[i-1].origUtilPlan, plans[i-1].origWlPlan);
        		p.updateNetLoadStatus(plans[i-1].cpuLoad, plans[i-1].memLoad, plans[i-1].stoLoad);
        		p.updateNetDeploymentStatus(plans[i-1].deployPlan);//update deployments from the previous agent
            }
        	plans[i] = scheme.agents.get(i).generateFFPlan(timestamp, type, p, deploy_backup);//must be fixed in one run and just update at the end: scheme.GPlan.deployPlan
        	
        	//localCost += plans [i].totalLocalCost;//local cost as the sum of the agents' local cost??
        	//System.out.println("------------------------------");
        }
        
       	Utility.writePlansAndCosts(type, plans, run);
    	Utility.writeRequests(type, scheme.agents, run);
	    
	    deployLocal(plans, serverCloudlets);//based on outplans from this period we can easily drive assignments...
	    
	    Utility.writeOutputLoad(type, scheme.agents, plans, run, 0, 1);
    	Utility.writeGC(type, scheme.GPlan.globalCost, scheme.GPlan.totalLocalCost, run, 0, 1, 0, 0); 
    	
    	scheme.mastercosts[run][type] = new RunCost(run, type, scheme.GPlan.totalLocalCost, scheme.GPlan.globalCost);
    	
    	
    			                   
	}


	private void runBaseSrv(int Curr_ts, List<FogDevice> serverCloudlets) {
    	
		scheme.optBeta  = 0;
		scheme.optNumPlan = 1;
    	
		Plan [] plans = new Plan [Constants.NUM_EDGE_ROUTERS]; //array of candidate plans generated by all agents
    	
    	System.out.println("------------------------------Plan generation------------------------------");
        for (int i = 0; i < scheme.agents.size(); i++) {
        	plans [i] = scheme.agents.get(i).generateLOPlan(deploy_backup, Curr_ts, type);
        	System.out.println("------------------------------");
        }
        
        Utility.writePlansAndCosts(type, plans, run);
    	Utility.writeRequests(type, scheme.agents, run);
	    
	    deployLocal(plans, serverCloudlets);//based on outplans from this period we can easily drive assignments...
	    
	    Utility.writeOutputLoad(type, scheme.agents, plans, run, 0, 1);
    	Utility.writeGC(type, scheme.GPlan.globalCost, scheme.GPlan.totalLocalCost, run, 0, 1, 0,0); 
    	
    	scheme.mastercosts[run][type] = new RunCost(run, type, scheme.GPlan.totalLocalCost, scheme.GPlan.globalCost);
    	
    	
	}

	
	/**
     * Runs the optimal placement method
     * only the agents co-located with the access points (edge routers) participate in this step
	 * @param args2 
	 * @return 
     * @return returns the global plan
     */
    private void runOptimalSrv(String[] args, int Curr_ts, List<FogDevice> serverCloudlets) {
    	
    	ComboCosts EPOSPareto = new ComboCosts(scheme.methodType);//for keeping a record of pareto optimal points for this method with different beta values
    	Plan [][] plans = new Plan [Constants.NUM_EDGE_ROUTERS][Constants.EPOS_NUM_PLANS]; //array of candidate plans generated by all agents
    	ArrayList<Integer> selectedPlansIndex = new ArrayList<Integer>();// index of agents' selected plans coming from EPOS
    	
    	System.out.println("------------------------------Plan generation------------------------------");
        for (int i = 0; i < scheme.agents.size(); i++) {
        	plans [i] = scheme.agents.get(i).generatePlans(deploy_backup, Curr_ts);
        	//System.out.println("------------------------------");
        }
        if ((run == 0)&&(scheme.methodType == 0))
        	Utility.writeUnitCosts();
        String optimalRunDirectory = runEPOS(args, plans, EPOSPareto);
    	System.out.print("Optimal Output directory: " + optimalRunDirectory);
	    System.out.println(", beta: "+EPOSPareto.Runs.get(EPOSPareto.optRun).beta+", num of plans: "+ EPOSPareto.Runs.get(EPOSPareto.optRun).numberOfPlans+", global-cost: "+EPOSPareto.Runs.get(EPOSPareto.optRun).globalCost+", local-cost: "+EPOSPareto.Runs.get(EPOSPareto.optRun).localCost);
        
    	scheme.GPlan.globalCost = EPOSPareto.Runs.get(EPOSPareto.optRun).globalCost;
    	scheme.GPlan.totalLocalCost = EPOSPareto.Runs.get(EPOSPareto.optRun).localCost;
    	scheme.optBeta = EPOSPareto.Runs.get(EPOSPareto.optRun).beta;
    	scheme.optNumPlan = EPOSPareto.Runs.get(EPOSPareto.optRun).numberOfPlans;
    	
    	double selGC = Utility.getSelInputFromEpos(EPOSPareto.Runs.get(EPOSPareto.optRun).optRun, EPOSPareto.Runs.get(EPOSPareto.optRun).localCost, EPOSPareto.Runs.get(EPOSPareto.optRun).globalCost, optimalRunDirectory, scheme.agents, scheme.methodType, plans, selectedPlansIndex, run, EPOSPareto.Runs.get(EPOSPareto.optRun).beta, EPOSPareto.Runs.get(EPOSPareto.optRun).numberOfPlans, EPOSPareto.Runs.get(EPOSPareto.optRun).nGlobalCost, EPOSPareto.Runs.get(EPOSPareto.optRun).nLocalCost);
    	//System.out.println("Optimal global-cost "+selGC);
    	
    	//run method deploy services and update scheme.deploy for next run:
    	deployEposAnswer(selectedPlansIndex, plans, serverCloudlets);//based on outplans from this period we can easily drive assignments...
    	  
    	scheme.mastercosts[scheme.run][scheme.methodType] = new RunCost(scheme.run, scheme.methodType, scheme.GPlan.totalLocalCost, scheme.GPlan.globalCost);
    	
    }

    /**
     * @param args
     * @param Agents
     * @param planList
     * @param ePOSCosts
     * @return
     * runs epos for all beta values and different number of plans
     */
    private String runEPOS(String[] args, Plan[][] planList, ComboCosts ePOSCosts) {
    	
		for (int bet = 0 ; bet<Constants.betaConfigSize ; bet++){
    		//for (int plaNum = 0; plaNum < Constants.PlanConfigSize; plaNum++) {
	    		System.out.println("---------------------------------------------------");
		        System.out.println("EPOS Run, beta=" + Constants.BetaConfig[bet]);
		        System.out.println("---------------------------------------------------");
	            Utility.setEPOSPropFile(Constants.BetaConfig[bet]);
		        IEPOSExperiment iepos = new IEPOSExperiment();
		        iepos.main(args);
		        
	    		//}
    	}
    	//set to init lambda value:not needed any more.    	//Utility.setEPOSPropFile(Constants.BetaConfig[0]);   
    	
    	
    	return readObjectiveCosts(Utility.GetLastFiles("output"), ePOSCosts, planList);
    	
	}

    /**
	 * @param listOfFiles
	 * @param epOSCosts
	 * @param agentList
	 * @param planlist
	 * @return the optimal epos run based on global/local cost among all runs (various beta values and Num. of plans)
	 */
	private String readObjectiveCosts(File[] listOfFiles, ComboCosts epOSCosts, Plan[][] planlist) {
		
		int OptFileIndex;
		System.out.println("---------------------------------------------------");
        System.out.println("Reading results from EPOS before normalization......");
        
        int firstFileIndex = listOfFiles.length - Constants.betaConfigSize;//number of last epos runs
		
        for (int betaindex = 0; betaindex <Constants.betaConfigSize ; betaindex++) {
			//for (int plaNum = 0; plaNum < Constants.PlanConfigSize; plaNum++) {
			ArrayList<Integer> selectedPlans = new ArrayList<Integer>();//records the index of selected plans coming from EPOS
	    	System.out.print("BetaIndex: "+ betaindex+" , file: "+listOfFiles[betaindex+firstFileIndex].getName());
			Utility.extractCosts(run, scheme.methodType, betaindex, Constants.PlanConfig[0], scheme.agents, planlist, selectedPlans, "output/" + listOfFiles[betaindex+firstFileIndex].getName(), epOSCosts);
			//double eqGC = Utility.getInputFromEpos(optimalRun, agents, plans, selectedPlansIndex, run);
	    	//}
			//Constants.BetaConfig[betaindex], Constants.PlanConfig[0],
		}
        
		OptFileIndex = epOSCosts.OptPoint(run);
		
		return listOfFiles[OptFileIndex+firstFileIndex].getName();
		
	}

	

	/**deploys selected plans, allocates resources and executes services
     * I-EPOS plan indexes come form input; one plan (index) per node.
     * Please note that the plans are applied from the first agent index
     * @param selectedPIndex
     * @param plans
     * @param agents
     * @param services
     * @param serverCloudlets
	 * @param ma22 
     * @param scheme 
     * @return
     */
    public void deployEposAnswer(ArrayList<Integer> selectedPIndex, Plan[][] plans, List<FogDevice> serverCloudlets){
    	//gets binary plans and workload plans and then updates the nodes' capacity and deploys services 
    	int host;
    	int numOfNodes = Constants.numNodes;
    	int serviceSize = 0;
    	int assToCloud = 0;
    	int unassigned = 0;
    	int agentIndex;
    	//for (int i = 0; i <2*numOfNodes; i++)
    	//	System.out.print(" "+scheme.GPlan.utilPlan[i]);
    	//System.out.println();
    	System.out.println("Applying generated plans....");
        
    	//the temporary load that is going to be assigned to the nodes as a result of this plan:
    	double [] tempCPULoad = new double [numOfNodes];//initialize to zero
    	double [] tempMemLoad = new double [numOfNodes];//initialize to zero
    	double [] tempStorageLoad = new double [numOfNodes];//initialize to zero
    	
        
        for (agentIndex = 0; agentIndex < scheme.agents.size(); agentIndex++){//apply all selected plans for all agents
        	
        	if (scheme.agents.get(agentIndex).getServiceSize() != 0) {
	        	serviceSize = scheme.agents.get(agentIndex).serviceList.size();
	        	Plan splan = plans[agentIndex][selectedPIndex.get(agentIndex)];
	        	System.out.println("Agent "+agentIndex+" service size:"+serviceSize+ " "+scheme.agents.get(agentIndex).getServiceSize());
                
            for (int i = 0 ; i < serviceSize ; i++){//all services of one node 
            	host = splan.y[i];
                		if (enoughCapacity(host, scheme.agents.get(agentIndex).serviceList.get(i), tempCPULoad[host], tempMemLoad[host], tempStorageLoad[host])) {
                			//System.out.println("1		cpu req: "+host+" "+tempCPULoad[host]);
		                	tempCPULoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getCpuDemand1();
		                	tempMemLoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getMemDemand();
		                	tempStorageLoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getStorageDemand();
		                	//scheme.GPlan.x[agents.get(agentIndex).serviceList.get(i).getServicId()][host] = 1 ;//update scheme.x for next run and costs
		                	//scheme.GPlan.y[agents.get(agentIndex).serviceList.get(i).getServicId()] = host;
		                	//scheme.GPlan.deployPlan[host] = true; //update scheme.deployplan for next run and costs
		                	scheme.GPlan.updatePlan(host, scheme.agents.get(agentIndex).serviceList.get(i).getServicId(), scheme.agents.get(agentIndex).serviceList.get(i),  Constants.FP[host], 
		                			Constants.FM[host], Constants.SC_MaxPow[host], Constants.SC_IdlePow[host]);
		                	//System.out.println("2		cpu req: "+host+" "+tempCPULoad[host]);
		                	
                		}
		                else 
		                {
		                	host = assignToCloud();
		                	if (enoughCapacity(host, scheme.agents.get(agentIndex).serviceList.get(i), tempCPULoad[host], tempMemLoad[host], tempStorageLoad[host])) {
		                	    System.out.println("Assigining to cloud due to resource scarcity on the edge network "+host);
		    	            
			                	tempCPULoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getCpuDemand1();
			                	tempMemLoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getMemDemand();
			                	tempStorageLoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getStorageDemand();
			                	
			                	//scheme.GPlan.x[agents.get(agentIndex).serviceList.get(i).getServicId()][host] = 1 ;
			                	//scheme.GPlan.y[agents.get(agentIndex).serviceList.get(i).getServicId()] = host;
			                	//scheme.GPlan.deployPlan[host] = true;
			                	scheme.GPlan.updatePlan(host, scheme.agents.get(agentIndex).serviceList.get(i).getServicId(), scheme.agents.get(agentIndex).serviceList.get(i),  Constants.FP[host], 
			                			Constants.FM[host], Constants.SC_MaxPow[host], Constants.SC_IdlePow[host]);
			                
			                	assToCloud++;
		                	
		                	}
		                	else {
		                		System.out.println("Debug! cloud center without capacity");
		                		unassigned++;
		                	}
		                }
            	}//all services
        	}//if not empty
        	
         }//end of applying all plans to the network nodes
        
        scheme.GPlan.setAssToCloud(assToCloud);
        scheme.GPlan.setUnassTasks(unassigned); 
        
        calCostsAfterDeployment(scheme.GPlan, selectedPIndex, plans, serverCloudlets);
        Utility.writeResults(scheme);
        
   	 
    } 
    
    
    public void deployLocal(Plan[] plans, List<FogDevice> serverCloudlets){
    	//gets binary plans and workload plans and then updates the nodes' capacity and deploys services 
    	int host;
    	int numOfNodes = Constants.numNodes;
    	int serviceSize = 0;
    	int assToCloud = 0;
    	int unassigned = 0;
    	int agentIndex;
    	//for (int i = 0; i <2*numOfNodes; i++)
    	//	System.out.print(" "+scheme.GPlan.utilPlan[i]);
    	//System.out.println();
    	System.out.println("Applying generated plans....");
        
    	//the temporary load that is going to be assigned to the nodes as a result of this plan:
    	double [] tempCPULoad = new double [numOfNodes];//initialize to zero
    	double [] tempMemLoad = new double [numOfNodes];//initialize to zero
    	double [] tempStorageLoad = new double [numOfNodes];//initialize to zero
    	
        
        for (agentIndex = 0; agentIndex < scheme.agents.size(); agentIndex++){//apply all selected plans for all agents
        	
        	if (scheme.agents.get(agentIndex).getServiceSize() != 0) {
	        	serviceSize = scheme.agents.get(agentIndex).serviceList.size();
	        	Plan splan = plans[agentIndex];
	        	System.out.println("Agent "+agentIndex+" service size:"+serviceSize+ " "+scheme.agents.get(agentIndex).getServiceSize());
                
	        	for (int i = 0 ; i < serviceSize ; i++){//all services of one node 
            			host = splan.y[i];
                		if (enoughCapacity(host, scheme.agents.get(agentIndex).serviceList.get(i), tempCPULoad[host], tempMemLoad[host], tempStorageLoad[host])) {
                			//System.out.println("1		cpu req: "+host+" "+tempCPULoad[host]);
		                	tempCPULoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getCpuDemand1();
		                	tempMemLoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getMemDemand();
		                	tempStorageLoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getStorageDemand();
		                	//scheme.GPlan.x[agents.get(agentIndex).serviceList.get(i).getServicId()][host] = 1 ;//update scheme.x for next run and costs
		                	//scheme.GPlan.y[agents.get(agentIndex).serviceList.get(i).getServicId()] = host;
		                	//scheme.GPlan.deployPlan[host] = true; //update scheme.deployplan for next run and costs
		                	scheme.GPlan.updatePlan(host, scheme.agents.get(agentIndex).serviceList.get(i).getServicId(), scheme.agents.get(agentIndex).serviceList.get(i),  Constants.FP[host], 
		                			Constants.FM[host], Constants.SC_MaxPow[host], Constants.SC_IdlePow[host]);
		                	
                		}
		                else 
		                {
		                	host = assignToCloud();
		                	if (enoughCapacity(host, scheme.agents.get(agentIndex).serviceList.get(i), tempCPULoad[host], tempMemLoad[host], tempStorageLoad[host])) {
		                	    System.out.println("Assigining to cloud due to resource scarcity on the edge network "+host);
		    	            
			                	tempCPULoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getCpuDemand1();
			                	tempMemLoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getMemDemand();
			                	tempStorageLoad[host] += scheme.agents.get(agentIndex).serviceList.get(i).getStorageDemand();
			                	
			                	//scheme.GPlan.x[agents.get(agentIndex).serviceList.get(i).getServicId()][host] = 1 ;
			                	//scheme.GPlan.y[agents.get(agentIndex).serviceList.get(i).getServicId()] = host;
			                	//scheme.GPlan.deployPlan[host] = true;
			                	scheme.GPlan.updatePlan(host, scheme.agents.get(agentIndex).serviceList.get(i).getServicId(), scheme.agents.get(agentIndex).serviceList.get(i),  Constants.FP[host], 
			                			Constants.FM[host], Constants.SC_MaxPow[host], Constants.SC_IdlePow[host]);
			                
			                	assToCloud++;
		                	
		                	}
		                	else {
		                		System.out.println("Debug! cloud center without capacity");
		                		unassigned++;
		                	}
		                }
            	}//all services
        	}//if not empty
        	
         }//end of applying all plans to the network nodes
        
        scheme.GPlan.setAssToCloud(assToCloud);
        scheme.GPlan.setUnassTasks(unassigned); 
        
        double[] PCCDcosts = new double[5];//saves costs for processing, storage, Memory, deployment, communication
    	double energyCost = 0, emissionCost = 0, dlCost = 0;
    	double[] ENCostParts = new double[3];
    	
	   	costOfComProcDep = new ComProcessDepStorCost(scheme.workload.getServiceList(), serverCloudlets);
		double procStorDeplCommCost = costOfComProcDep.calProcStorDepCommCostAfterDeployment(scheme.GPlan, scheme.agents, PCCDcosts, deploy_backup);//scheme.GPlan.deployPlan
		
		eC = new EnergyCost(scheme.workload.getServiceList());
		if (Constants.APPLIEDCOST[6] == 1)
			if (scheme.currentVehiclesInAreaToPlan == 0)
				energyCost = 0;
			else
   		 		energyCost = eC.calEnergyCost(scheme.GPlan, scheme.agents, ENCostParts, true);
   	 
		if (Constants.APPLIEDCOST[7] == 1)
			if (scheme.currentVehiclesInAreaToPlan == 0)
				emissionCost = 0;
			else
				emissionCost = eC.getCO2Cost();
   	
		if (Constants.APPLIEDCOST[0] != 0) {
			if (scheme.currentVehiclesInAreaToPlan == 0)
				dlCost = 0;
			else {
		   		 sD = new ServiceDelay(scheme.workload.getServiceList(), serverCloudlets);
		   		 sD.initialize(scheme.GPlan);
				 dlCost = Constants.APPLIEDCOST[0] * calDLViolationCost(scheme.GPlan, scheme.agents);
				}
		}
		
		scheme.GPlan.setDlViolCost(dlCost);
		scheme.GPlan.setProcCost(PCCDcosts[0]);
		scheme.GPlan.setStorCost(PCCDcosts[1]);
		scheme.GPlan.setMemCost(PCCDcosts[2]);
		scheme.GPlan.setCommCost(PCCDcosts[3]);
		scheme.GPlan.setDeplCost(PCCDcosts[4]);
		scheme.GPlan.setEnergyCost(energyCost);
		scheme.GPlan.setCo2EmitCost(emissionCost);
		scheme.GPlan.setTotalLocalCost();
		scheme.GPlan.setENCosts(ENCostParts);
		scheme.GPlan.globalCost = scheme.GPlan.calculateGlobalFunc();
    	
        Utility.writeResults(scheme);
        
   	} 
    
    private void calCostsAfterDeployment(Plan gPlan, ArrayList<Integer> selectedPIndex, Plan[][] plans, List<FogDevice> serverCloudlets) {
   	
    	double[] PCCDcosts = new double[5];//saves costs for processing, storage, Memory, deployment, communication
    	double energyCost = 0, emissionCost = 0, dlCost = 0;
    	double[] ENCostParts = new double[3];
	   
    	costOfComProcDep = new ComProcessDepStorCost(scheme.workload.getServiceList(), serverCloudlets);
		double procStorDeplCommCost = costOfComProcDep.calProcStorDepCommCostAfterDeployment(gPlan, scheme.agents, PCCDcosts, deploy_backup);
		
		eC = new EnergyCost(scheme.workload.getServiceList());
		if (Constants.APPLIEDCOST[6] == 1)
			if (scheme.currentVehiclesInAreaToPlan == 0)
				energyCost = 0;
			else
   		 		energyCost = eC.calEnergyCost(gPlan, scheme.agents, ENCostParts, true);
   	 
		if (Constants.APPLIEDCOST[7] == 1)
			if (scheme.currentVehiclesInAreaToPlan == 0)
				emissionCost = 0;
			else
				emissionCost = eC.getCO2Cost();
   	
		if (Constants.APPLIEDCOST[0] != 0) {
			if (scheme.currentVehiclesInAreaToPlan == 0)
				dlCost = 0;
			else {//here the scheme.gplan.deployplan will be updated for next run
		   		 sD = new ServiceDelay(scheme.workload.getServiceList(), serverCloudlets);
		   		 sD.initialize(gPlan);
				 dlCost = Constants.APPLIEDCOST[0] * calDLViolationCost(gPlan, scheme.agents);
			}
		}
		
		gPlan.setDlViolCost(dlCost);
		gPlan.setProcCost(PCCDcosts[0]);
		gPlan.setStorCost(PCCDcosts[1]);
		gPlan.setMemCost(PCCDcosts[2]);
		gPlan.setCommCost(PCCDcosts[3]);
		gPlan.setDeplCost(PCCDcosts[4]);
		gPlan.setEnergyCost(energyCost);
		gPlan.setCo2EmitCost(emissionCost);
		gPlan.setENCosts(ENCostParts);
		gPlan.setTotalLocalCost();
		scheme.GPlan.globalCost = scheme.GPlan.calculateGlobalFunc();
    	
   	 
   
    }
        
    public double calDLViolationCost(Plan gp, List<Agent> agents) {
    	
    	v = new Violation();
    	double violCost = 0;
		
    	for (int a =0; a <agents.size(); a++) {
		    linkDelayTranmiRateWaitTime(gp, agents.get(a).serviceList, agents.get(a).vehicleConnectedAPsPerRunAgent);
		    
		}
	   
    	for (int a =0; a <agents.size(); a++) {
    		violCost += v.costViol(agents.get(a).vehicleConnectedAPsPerRunAgent, agents.get(a).serviceList);
    		
    	}
    	
		return violCost;
    	
    }
	
    public void linkDelayTranmiRateWaitTime(Plan p, List<MobileARservice> serviceList, List<MetricsForVehisFromIntermediateAP> vehicleConnectedAPsPerRun) {
 	   	
		int i, hostIndex;
	    
 	    for (i = 0 ; i<serviceList.size() ; i++) {
 	    	hostIndex = p.y[serviceList.get(i).getServicId()];//host node
   			vehicleConnectedAPsPerRun.get(i).PropagDelayTransRate(hostIndex);
   			
 	   }
 	    //here the deployment plan for global plan is updated:
 	   for (i = 0; i<serviceList.size(); i++) {
		   sD.calcServiceDelay(serviceList.get(i).getServicId(), p.y[serviceList.get(i).getServicId()], vehicleConnectedAPsPerRun.get(i), deploy_backup);
       }
			
  	}
	
   
	/**
	 * Checks if Equations 18-20 are satisfied
	 * @param FogDevId
	 * @param service
	 * @param pre_cpu
	 * @param pre_mem
	 * @param pre_storage
	 * @return true if FogDevId has enough storage and memory available for this service
	 */
	public boolean enoughCapacity(int FogDevId, MobileARservice service, double pre_cpu, double pre_mem, double pre_storage) {
			
		if (((service.getCpuDemand1() + pre_cpu) > (Constants.cpuUtilRatio * Constants.FP[FogDevId])) ||
 				((service.getMemDemand() + pre_mem) > (Constants.memUtilRatio * Constants.FM[FogDevId])) || 
 				((service.getStorageDemand() + pre_storage) > (Constants.stoUtilRatio * Constants.FS[FogDevId]))){
           return false;
 		}
 		else { 
 			return true;
 	    }
		}
	
	/**
	 * @return id of a cloud server in random
	 * in this experiment the last node is cloud center
	 */
	public int assignToCloud() {
		
		return (Constants.NUM_BACKBONE_ROUTERS+Constants.NUM_EDGE_ROUTERS -1);
}
	

}